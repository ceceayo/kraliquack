{"actions": [{"name": "GameStarted", "code": "width  = 75\nheight = 75\n\ntime = 0\nt2 = 0\n\ntiles = {}\n\ngenerators = {}\n\nentities = {}\nec = 0\n\nfor y = 0, height do\n    for x = 0, width do\n        if y == 0 or y == height or x == 0 or x == width - 1 then\n            tiles[y * width + x] = {x = x, y = y, tile = \"#\", owner = \"system\"}\n        elseif (y * width + x) % 13 == 3 then\n            tiles[y * width + x] = {x = x, y = y, tile = \"r\", owner = \"\"}\n        else\n            tiles[y * width + x] = {x = x, y = y, tile = \".\", owner = \"\"}\n        end\n    end\nend\n\nLog(\"Created board :p\")\n\n\nLog(\"Total tiles: \" .. tostring(#tiles))\n\nc = 0"}, {"name": "Preamble", "code": "function iterateDict(d)\n    local enumerator = d:GetEnumerator()\n    return function()\n        if enumerator:MoveNext() then\n            local pair = enumerator.Current\n            return pair.Key, pair.Value\n        end\n    end\nend\n\nfunction dump(o)\n    if type(o) == 'table' then\n       local s = '{ '\n       for k,v in pairs(o) do\n          if type(k) ~= 'number' then k = '\"'..k..'\"' end\n          s = s .. '['..k..'] = ' .. dump(v) .. ','\n       end\n       return s .. '} '\n    else\n       return tostring(o)\n    end\nend\n\n\n \n\nfunction isValidCell(x,y)\n    if x < 0 or x >= width then\n        return false\n    end\n    if y < 0 or y >= height then\n        return false\n    end\n    return true\nend\n\n\nfunction cellCanBeBuiltOn(x,y)\n    tile = tiles[y * width + x]\n    if tile.owner ~= \"\" then\n        return false\n    else\n        if tile.tile == \".\" then\n            return true\n        else\n            return false\n        end\n    end\nend\n\nfunction userMakePurchase(u,a)\n    current_cash = tonumber(users[u].Data[\"cash\"])\n    if current_cash < a then\n        MessageUser(u, \"chat\", \"Purchase failed - not enough cash\")\n        return false\n    else\n        return true\n    end\nend\n\nfunction userRequirePower(u,a)\n    current_power = tonumber(users[u].Data[\"powerGeneration\"]) - tonumber(users[u].Data[\"powerConsumption\"])\n    if current_power < a then\n        MessageUser(u, \"chat\", \"Out of power\")\n        return false\n    else\n        return true\n    end\nend\n\nfunction userMakePurchaseApply(u,a)\n    current_cash = tonumber(users[u].Data[\"cash\"])\n    if current_cash < a then\n        return false\n    else\n        current_cash = current_cash - a\n        users[u].Data[\"cash\"] = tostring(current_cash)\n        MessageUser(u, \"cash\", tostring(current_cash))\n        return true\n    end\nend\n\nfunction userRequirePowerApply(u,a)\n    current_power = tonumber(users[u].Data[\"powerGeneration\"]) - tonumber(users[u].Data[\"powerConsumption\"])\n    if current_power < a then\n        return false\n    else\n        current_power = current_power - a\n        users[u].Data[\"powerConsumption\"] = tostring(tonumber(users[u].Data[\"powerConsumption\"]) + a)\n        MessageUser(u, \"power\", users[u].Data[\"powerGeneration\"] .. \" \" .. users[u].Data[\"powerConsumption\"])\n        return true\n    end\nend\n\nfunction split(str, pat)\n    local t = {}  -- NOTE: use {n = 0} in Lua-5.0\n    local fpat = \"(.-)\" .. pat\n    local last_end = 1\n    local s, e, cap = str:find(fpat, 1)\n    while s do\n       if s ~= 1 or cap ~= \"\" then\n          table.insert(t, cap)\n       end\n       last_end = e+1\n       s, e, cap = str:find(fpat, last_end)\n    end\n    if last_end <= #str then\n       cap = str:sub(last_end)\n       table.insert(t, cap)\n    end\n    return t\n end\n"}, {"name": "Tick", "code": "time = time + delta\nt2 = t2 + delta\n\n\nfor k, v in iterateDict(users) do\n    da = \"\"\n    db = \"\"\n    --Log(tostring(c))\n    for i = 0, 99 do\n        da = da .. tostring((c+i)%#tiles) .. \",\" .. tostring(tiles[(c+i)%#tiles].tile) .. \":\"\n        if tiles[(c+i)%#tiles].owner ~= \"\" then\n            db = db .. tostring((c+i)%#tiles) .. \",\" .. tostring(tiles[(c+i)%#tiles].owner) .. \":\"\n        end\n    end\n    MessageUser(k, \"board\", da) -- Send the constructed message to the user\n    MessageUser(k, \"owner\", db) -- Send the constructed message to the user\n\n    \nend\n\nc = c + 99\nc = c % #tiles\n\n\n-- Each second, add cashGeneration to cash\nif t2 >= 1 then\n    t2 = t2 - 1\n    for k, v in iterateDict(users) do\n        users[k].Data[\"cash\"] = tostring(tonumber(v.Data[\"cash\"]) + tonumber(v.Data[\"cashGeneration\"]))\n        MessageUser(k, \"cash\", users[k].Data[\"cash\"])\n    end\n    for k, v in pairs(generators) do\n        generators[k].time = generators[k].time + 1\n        if generators[k].time == generators[k].timeNeeded then\n            if generators[k].type == \"soldier\" then\n                if users[generators[k].owner].Data[\"team\"] == \"1\" then\n                    entities[ec] = {x = generators[k].x, y = generators[k].y, type = \"duck\", owner = generators[k].owner, orientation = 0, speed = 0, health = 25}\n                else\n                    entities[ec] = {x = generators[k].x, y = generators[k].y, type = \"bug\", owner = generators[k].owner, orientation = 0, speed = 0, health = 25}\n                end\n                \n                for k2,v2 in iterateDict(users) do\n                    MessageUser(k2, \"entity\", tostring(ec) .. \",\" .. tostring(entities[ec].x) .. \",\" .. tostring(entities[ec].y) .. \",\" .. tostring(entities[ec].type) .. \",\" .. tostring(entities[ec].owner) .. \",\" .. tostring(entities[ec].orientation) .. \",\" .. tostring(entities[ec].speed) .. \",\" .. tostring(entities[ec].health))\n                end\n                ec = ec + 1\n            elseif generators[k].type == \"tank\" then\n                if users[generators[k].owner].Data[\"team\"] == \"1\" then\n                    entities[ec] = {x = generators[k].x, y = generators[k].y, type = \"ducktank\", owner = generators[k].owner, orientation = 0, speed = 0, health = 80}\n                else\n                    entities[ec] = {x = generators[k].x, y = generators[k].y, type = \"bugtank\", owner = generators[k].owner, orientation = 0, speed = 0, health = 80}\n                end\n                \n                for k2,v2 in iterateDict(users) do\n                    MessageUser(k2, \"entity\", tostring(ec) .. \",\" .. tostring(entities[ec].x) .. \",\" .. tostring(entities[ec].y) .. \",\" .. tostring(entities[ec].type) .. \",\" .. tostring(entities[ec].owner) .. \",\" .. tostring(entities[ec].orientation) .. \",\" .. tostring(entities[ec].speed) .. \",\" .. tostring(entities[ec].health))\n                end\n                ec = ec + 1\n            end\n            generators[k] = nil\n        end\n    end\nend\n"}, {"name": "UserAction Chat", "code": "s = \"<\" .. userToken .. \"> \" .. actionData\n\nfor k,v in iterateDict(users) do\n    MessageUser(k, \"chat\", s)\nend"}, {"name": "UserAction PlaceBarracks", "code": "\nif users[userToken].Data[\"progressionState\"] ~= \"placedHQ\" and users[userToken].Data[\"progressionState\"] ~= \"placedBarracks\" and users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif cellCanBeBuiltOn(x,y) == false then\n    Log(\"Cell cannot be built on\")\n    return\nend\n\nif userMakePurchase(userToken, 1000) == false then\n    Log(\"User cannot afford Barracks\")\n    return\nend\n\nif userRequirePower(userToken, 30) == false then\n    Log(\"User does not have enough power\")\n    return\nend\n\nLog(\"All checks passed\")\n\nuserMakePurchaseApply(userToken, 1000)\nuserRequirePowerApply(userToken, 30)\n\ntiles[y * width + x].tile = \"b\"\ntiles[y * width + x].owner = userToken\n\n\nif users[userToken].Data[\"progressionState\"] == \"placedHQ\" then\n    users[userToken].Data[\"progressionState\"] = \"placedBarracks\"\n    MessageUser(userToken, \"progressionState\", \"placedBarracks\")\nend\n\n\n\nfor k, v in iterateDict(users) do\n    MessageUser(k, \"board\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].tile))\n    MessageUser(k, \"owner\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].owner))\t\nend\n\n"}, {"name": "UserAction PlaceFactory", "code": "\nif users[userToken].Data[\"progressionState\"] ~= \"placedBarracks\" and users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif cellCanBeBuiltOn(x,y) == false then\n    Log(\"Cell cannot be built on\")\n    return\nend\n\nif userMakePurchase(userToken, 8000) == false then\n    Log(\"User cannot afford Barracks\")\n    return\nend\n\nif userRequirePower(userToken, 60) == false then\n    Log(\"User does not have enough power\")\n    return\nend\n\nLog(\"All checks passed\")\n\nuserMakePurchaseApply(userToken, 8000)\nuserRequirePowerApply(userToken, 60)\n\ntiles[y * width + x].tile = \"f\"\ntiles[y * width + x].owner = userToken\n\n\nif users[userToken].Data[\"progressionState\"] == \"placedBarracks\" then\n    users[userToken].Data[\"progressionState\"] = \"placedFactory\"\n    MessageUser(userToken, \"progressionState\", \"placedFactory\")\nend\n\n\n\nfor k, v in iterateDict(users) do\n    MessageUser(k, \"board\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].tile))\n    MessageUser(k, \"owner\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].owner))\t\nend\n\n"}, {"name": "UserAction PlaceHeadQuarters", "code": "\nif users[userToken].Data[\"progressionState\"] ~= \"joined\" then\n    Log(\"User not in joined state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\nteam = tonumber(data[3])\n\nif team ~= 1 and team ~= 2 then\n    Log(\"Invalid team\")\n    return\nend\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif cellCanBeBuiltOn(x,y) == false then\n    Log(\"Cell cannot be built on\")\n    return\nend\n\nif userMakePurchase(userToken, 2500) == false then\n    Log(\"User cannot afford HQ\")\n    return\nend\n\nLog(\"All checks passed\")\n\nuserMakePurchaseApply(userToken, 2500)\n\nif team == 1 then\n    tiles[y * width + x].tile = \"h\"\nelse\n    tiles[y * width + x].tile = \"H\"\nend\ntiles[y * width + x].owner = userToken\n\n\n\nusers[userToken].Data[\"progressionState\"] = \"placedHQ\"\nMessageUser(userToken, \"progressionState\", \"placedHQ\")\nusers[userToken].Data[\"team\"] = tostring(team)\n\nfor k,v in iterateDict(users) do\n    MessageUser(k, \"board\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].tile))\n    MessageUser(k, \"owner\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].owner))\t\n    MessageUser(k, \"userTeam\", userToken .. \",\" .. tostring(team))\n    MessageUser(k, \"chat\", \"User \" .. userToken .. \" has placed their HQ at \" .. tostring(x) .. \",\" .. tostring(y) .. \" for team \" .. tostring(team))\nend\n\nusers[userToken].Data[\"hqPos\"] = tostring(y*width+x)\n\n\nusers[userToken].Data[\"hqHealth\"] = \"350\"\nMessageUser(userToken, \"hqHealth\", \"350\")"}, {"name": "UserAction PlaceMine", "code": "\nif users[userToken].Data[\"progressionState\"] ~= \"placedHQ\" and users[userToken].Data[\"progressionState\"] ~= \"placedBarracks\" and users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif cellCanBeBuiltOn(x,y) == false then\n    Log(\"Cell cannot be built on\")\n    return\nend\n\nif userMakePurchase(userToken, 1500) == false then\n    Log(\"User cannot afford Barracks\")\n    return\nend\n\nif userRequirePower(userToken, 30) == false then\n    Log(\"User does not have enough power\")\n    return\nend\n\nLog(\"All checks passed\")\n\nuserMakePurchaseApply(userToken, 1500)\nuserRequirePowerApply(userToken, 30)\n\ntiles[y * width + x].tile = \"m\"\ntiles[y * width + x].owner = userToken\n\n\nusers[userToken].Data[\"cashGeneration\"] = tostring(tonumber(users[userToken].Data[\"cashGeneration\"]) + 40)\nMessageUser(userToken, \"cashGeneration\", users[userToken].Data[\"cashGeneration\"])\t\n\nfor k, v in iterateDict(users) do\n    MessageUser(k, \"board\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].tile))\n    MessageUser(k, \"owner\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].owner))\t\nend\n\n"}, {"name": "UserAction PlacePowerPlant", "code": "\nif users[userToken].Data[\"progressionState\"] ~= \"placedHQ\" and users[userToken].Data[\"progressionState\"] ~= \"placedBarracks\" and users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif cellCanBeBuiltOn(x,y) == false then\n    Log(\"Cell cannot be built on\")\n    return\nend\n\nif userMakePurchase(userToken, 1000) == false then\n    Log(\"User cannot afford Powerplant\")\n    return\nend\n\nLog(\"All checks passed\")\n\nuserMakePurchaseApply(userToken, 1000)\n\ntiles[y * width + x].tile = \"p\"\ntiles[y * width + x].owner = userToken\n\nusers[userToken].Data[\"powerGeneration\"] = tostring(tonumber(users[userToken].Data[\"powerGeneration\"]) + 75)\nusers[userToken].Data[\"powerConsumption\"] = tostring(tonumber(users[userToken].Data[\"powerConsumption\"]) + 15)\n\nMessageUser(userToken, \"power\", users[userToken].Data[\"powerGeneration\"] .. \" \" .. users[userToken].Data[\"powerConsumption\"])\n\nfor k, v in iterateDict(users) do\n    MessageUser(k, \"owner\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].owner))\t\n    MessageUser(k, \"board\", tostring(y*width+x) .. \",\" .. tostring(tiles[y * width + x].tile))\nend\n\n"}, {"name": "UserAction ShootEntity", "code": "values = split(actionData, \" \")\n\nif #values ~= 2 then\n    Log(\"Invalid data length\")\n    return\nend\n\nshooter = tonumber(values[1])\ntarget = tonumber(values[2])\n\nif shooter == nil or target == nil then\n    Log(\"Invalid shooter or target\")\n    return\nend\n\nif entities[shooter] == nil or entities[target] == nil then\n    Log(\"Invalid shooter or target entity\")\n    return\nend\n\nif entities[shooter].owner ~= userToken then\n    Log(\"Shooter does not own the entity\")\n    return\nend\n\nif entities[shooter].type ~= \"duck\" and entities[shooter].type ~= \"bug\" then\n    Log(\"Shooter is not of a known type.\")\n    return\nend\n\ndamage = 0\n\nif entities[shooter].type == \"duck\" then\n    damage = 1\nelseif entities[shooter].type == \"bug\" then\n    damage = 1\nend\n\n\nentities[target].health = entities[target].health - damage\n\nif entities[target].health <= 0 then\n    Log(\"Entity \" .. tostring(target) .. \" has been destroyed.\")\n    for k,v in iterateDict(users) do\n        MessageUser(k, \"entityDestroyed\", tostring(target))\n    end\n    entities[target] = nil\nelse\n    for k,v in iterateDict(users) do\n        MessageUser(k, \"entityDamage\", tostring(target) .. \",\" .. tostring(damage) .. \",\" .. tostring(entities[target].health))\n    end\nend\n"}, {"name": "UserAction ShootHQ", "code": "values = split(actionData, \" \")\n\nif #values ~= 3 then\n    Log(\"Invalid data length\")\n    return\nend\n\nshooter = tonumber(values[1])\ntargetx = tonumber(values[2])\ntargety = tonumber(values[3])\n\nif shooter == nil or targetx == nil or targety == nil then\n    Log(\"Invalid shooter or target\")\n    return\nend\n\nif targetx < 0 or targetx >= width or targety < 0 or targety >= height then\n    Log(\"Target out of bounds\")\n    return\nend\n\ntarget = tiles[targety * width + targetx]\n\nif entities[shooter] == nil or target == nil then\n    Log(\"Invalid shooter or target entity\")\n    return\nend\n\nif entities[shooter].owner ~= userToken then\n    Log(\"Shooter does not own the entity\")\n    return\nend\n\nif entities[shooter].type ~= \"duck\" and entities[shooter].type ~= \"bug\" then\n    Log(\"Shooter is not of a known type.\")\n    return\nend\n\nif target.tile ~= \"h\" and target.tile ~= \"H\" then\n    Log(\"Target is not a HQ\")\n    return\nend\n\nif target.owner == entities[shooter].owner then\n    Log(\"Target is owned by the shooter\")\n    return\nend\n\ndamage = 0\n\nif entities[shooter].type == \"duck\" then\n    damage = 1\nelseif entities[shooter].type == \"bug\" then\n    damage = 1\nend\n\n\ntargetuser = target.owner\n\nif targetuser == nil then\n    Log(\"Target has no owner\")\n    return\nend\n\nif users[targetuser] == nil then\n    Log(\"Target user does not exist\")\n    return\nend\n\nusers[targetuser].Data[\"hqHealth\"] = tostring(tonumber(users[targetuser].Data[\"hqHealth\"]) - damage)\n\nMessageUser(targetuser, \"hqHealth\", tostring(tonumber(users[targetuser].Data[\"hqHealth\"])))\n\n\nif tonumber(users[targetuser].Data[\"hqHealth\"]) <= 0 then\n    Log(\"User \" .. tostring(targetuser) .. \" has been destroyed.\")\n    for k,v in iterateDict(users) do\n        MessageUser(k, \"userDestroyed\", tostring(targetuser))\n    end\n    users[targetuser].Data[\"progressionState\"] = \"destroyed\"\n    MessageUser(targetuser, \"progressionState\", \"destroyed\")\n    users[targetuser].Data[\"hqHealth\"] = \"0\"\n    tiles[tonumber(users[targetuser].Data[\"hqPos\"])].tile = \".\"\n    tiles[tonumber(users[targetuser].Data[\"hqPos\"])].owner = \"\"\n    users[targetuser].Data[\"hqPos\"] = nil\n    for k,v in iterateDict(users) do\n        MessageUser(k, \"board\", tostring(tonumber(users[targetuser].Data[\"hqPos\"])) .. \",\" .. \".\")\n        MessageUser(k, \"owner\", tostring(tonumber(users[targetuser].Data[\"hqPos\"])) .. \",\" .. \"\")\n        MessageUser(k, \"chat\", \"User \" .. targetuser .. \" has been destroyed.\")\n    end\nelse\n    for k,v in iterateDict(users) do\n        MessageUser(k, \"userDamage\", tostring(targetuser) .. \",\" .. tostring(users[targetuser].Data[\"hqHealth\"]))\n    end\nend\n"}, {"name": "UserAction SummonSoldier", "code": "if users[userToken].Data[\"progressionState\"] ~= \"placedBarracks\" and users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif userMakePurchase(userToken, 100) == false then\n    Log(\"User cannot afford Barracks\")\n    return\nend\n\nif generators[y * width + x] ~= nil then\n    Log(\"Generator already exists\")\n    return\nend\n\nif tiles[y * width + x].tile ~= \"b\" then\n    Log(\"Tile is not a barracks\")\n    return\nend\n\nif tiles[y * width + x].owner ~= userToken then\n    Log(\"Tile is not owned by user\")\n    return\nend\n\nLog(\"All checks passed\")\t\n\nuserMakePurchaseApply(userToken, 100)\n\ngenerators[y * width + x] = {}\ngenerators[y * width + x].owner = userToken\ngenerators[y * width + x].type = \"soldier\"\ngenerators[y * width + x].timeNeeded = 5\ngenerators[y * width + x].time = 0\ngenerators[y * width + x].x = x\ngenerators[y * width + x].y = y"}, {"name": "UserAction SummonTank", "code": "if users[userToken].Data[\"progressionState\"] ~= \"placedFactory\" then\n    Log(\"User in wrong state\")\n    return\nend\n\ndata = {}\nfor u in string.gmatch(actionData, \"%-?%d+\") do\n    data[#data + 1] = u\nend\n\nx = tonumber(data[1])\ny = tonumber(data[2])\n\n\ndata = nil\n\nLog(\"X: \" .. tostring(x))\nLog(\"Y: \" .. tostring(y))\n\n\nif isValidCell(x,y) == false then\n    Log(\"Invalid cell\")\n    return\nend\n\nif userMakePurchase(userToken, 1000) == false then\n    Log(\"User cannot afford Barracks\")\n    return\nend\n\nif generators[y * width + x] ~= nil then\n    Log(\"Generator already exists\")\n    return\nend\n\nif tiles[y * width + x].tile ~= \"f\" then\n    Log(\"Tile is not a factory\")\n    return\nend\n\nif tiles[y * width + x].owner ~= userToken then\n    Log(\"Tile is not owned by user\")\n    return\nend\n\nLog(\"All checks passed\")\t\n\nuserMakePurchaseApply(userToken, 1000)\n\ngenerators[y * width + x] = {}\ngenerators[y * width + x].owner = userToken\ngenerators[y * width + x].type = \"tank\"\ngenerators[y * width + x].timeNeeded = 25\ngenerators[y * width + x].time = 0\ngenerators[y * width + x].x = x\ngenerators[y * width + x].y = y"}, {"name": "UserAction UpdateEntity", "code": "values = split(actionData, \" \")\n\nif #values ~= 5 then\n    Log(\"Invalid number of arguments\")\n    return\nend\n\n\nid = tonumber(values[1])\nrotation = tonumber(values[2])\nspeed = tonumber(values[3])\nx = tonumber(values[4])\ny = tonumber(values[5])\n\nif id == nil or rotation == nil or speed == nil or x == nil or y == nil then\n    Log(\"Invalid arguments\")\n    return\nend\n\nif entities[id] == nil then\n    Log(\"Entity does not exist\")\n    return\nend\n\nif entities[id].owner ~= userToken then\n    Log(\"Entity does not belong to user\")\n    return\nend\n\nentities[id].x = x\nentities[id].y = y\nentities[id].orientation = rotation\nentities[id].speed = speed\n\n\nfor k,v in iterateDict(users) do\n    MessageUser(k, \"entity\", tostring(id) .. \",\" .. tostring(x) .. \",\" .. tostring(y) .. \",\" .. tostring(entities[id].type) .. \",\" .. tostring(entities[id].owner) .. \",\" .. tostring(rotation) .. \",\" .. tostring(speed) .. \",\" .. tostring(entities[id].health))\nend"}, {"name": "UserJoined", "code": "Log(\"Hello from UserJoined\")\nLog(tostring(tiles))\nMessageUser(joinedUserToken, \"test\", \"HELLO REDIS WORLD\")\n--informUserFullBoard(joinedUserToken)\nLog(\"User joined successfully\")\nLog(tostring(users[joinedUserToken]))\nLog(tostring(users[joinedUserToken].Data))\nusers[joinedUserToken].Data[\"progressionState\"] = \"joined\"\nMessageUser(joinedUserToken, \"progressionState\", \"joined\")\nusers[joinedUserToken].Data[\"cash\"] = \"5000\"\nMessageUser(joinedUserToken, \"cash\", \"5000\")\n--users[joinedUserToken].Data[\"cash\"] = \"99999999\"\n--MessageUser(joinedUserToken, \"cash\", \"99999999\")\nusers[joinedUserToken].Data[\"powerGeneration\"] = \"0\"\nusers[joinedUserToken].Data[\"powerConsumption\"] = \"0\"\nMessageUser(joinedUserToken, \"power\", \"0 0\")\nusers[joinedUserToken].Data[\"cashGeneration\"] = \"0\" -- per second\nMessageUser(joinedUserToken, \"cashGeneration\", \"0\")\nfor k, v in pairs(entities) do\n    MessageUser(joinedUserToken, \"entity\", tostring(v.id) .. \",\" .. tostring(v.x) .. \",\" .. tostring(v.y) .. \",\" .. tostring(v.type) .. \",\" .. tostring(v.owner) .. \",\" .. tostring(v.rotation) .. \",\" .. tostring(v.speed) .. \",\" .. tostring(v.health))\nend\nusers[joinedUserToken].Data[\"hqHealth\"] = \"0\"\nMessageUser(joinedUserToken, \"hqHealth\", \"0\")"}, {"name": "UserLeft", "code": "Log(\"ul\")\n\n"}], "name": "KRALIQUACK", "version": "0.0.1"}